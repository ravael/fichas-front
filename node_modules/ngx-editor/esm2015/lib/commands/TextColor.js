import { getSelectionMarks, isMarkActive } from 'ngx-editor/helpers';
import { applyMark, removeMark } from 'ngx-editor/commands';
class TextColor {
    constructor(name) {
        this.name = name;
    }
    apply(attrs) {
        return (state, dispatch) => {
            const { schema, selection, doc } = state;
            const type = schema.marks[this.name];
            if (!type) {
                return false;
            }
            const { from, to, empty } = selection;
            if (!empty && (from + 1 === to)) {
                const node = doc.nodeAt(from);
                if ((node === null || node === void 0 ? void 0 : node.isAtom) && !node.isText && node.isLeaf) {
                    // An atomic node (e.g. Image) is selected.
                    return false;
                }
            }
            return applyMark(type, attrs)(state, dispatch);
        };
    }
    isActive(state) {
        const { schema } = state;
        const type = schema.marks[this.name];
        if (!type) {
            return false;
        }
        return isMarkActive(state, type);
    }
    getActiveColors(state) {
        if (!this.isActive(state)) {
            return [];
        }
        const { schema } = state;
        const marks = getSelectionMarks(state);
        const colors = marks
            .filter(mark => mark.type === schema.marks[this.name])
            .map(mark => mark.attrs.color)
            .filter(Boolean);
        return colors;
    }
    remove() {
        return (state, dispatch) => {
            const { schema } = state;
            const type = schema.marks[this.name];
            if (!type) {
                return false;
            }
            return removeMark(type)(state, dispatch);
        };
    }
    canExecute(state) {
        const attrs = this.name === 'text_color' ? { color: '' } : { backgroundColor: '' };
        return this.apply(attrs)(state);
    }
}
export default TextColor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dENvbG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb21tYW5kcy9UZXh0Q29sb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBSUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFlBQVksRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3JFLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFjNUQsTUFBTSxTQUFTO0lBR2IsWUFBWSxJQUFVO1FBQ3BCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFRCxLQUFLLENBQUMsS0FBd0M7UUFDNUMsT0FBTyxDQUFDLEtBQWtCLEVBQUUsUUFBbUIsRUFBVyxFQUFFO1lBQzFELE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQztZQUV6QyxNQUFNLElBQUksR0FBYSxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMvQyxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNULE9BQU8sS0FBSyxDQUFDO2FBQ2Q7WUFFRCxNQUFNLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsR0FBRyxTQUFTLENBQUM7WUFFdEMsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUU7Z0JBQy9CLE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzlCLElBQUksQ0FBQSxJQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsTUFBTSxLQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO29CQUMvQywyQ0FBMkM7b0JBQzNDLE9BQU8sS0FBSyxDQUFDO2lCQUNkO2FBQ0Y7WUFFRCxPQUFPLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ2pELENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRCxRQUFRLENBQUMsS0FBa0I7UUFDekIsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQztRQUN6QixNQUFNLElBQUksR0FBYSxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUUvQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1QsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELE9BQU8sWUFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQsZUFBZSxDQUFDLEtBQWtCO1FBQ2hDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3pCLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFFRCxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDO1FBQ3pCLE1BQU0sS0FBSyxHQUFHLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXZDLE1BQU0sTUFBTSxHQUFHLEtBQUs7YUFDakIsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNyRCxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQzthQUM3QixNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFbkIsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELE1BQU07UUFDSixPQUFPLENBQUMsS0FBa0IsRUFBRSxRQUFtQixFQUFXLEVBQUU7WUFDMUQsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQztZQUV6QixNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNyQyxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNULE9BQU8sS0FBSyxDQUFDO2FBQ2Q7WUFFRCxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDM0MsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELFVBQVUsQ0FBQyxLQUFrQjtRQUMzQixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsZUFBZSxFQUFFLEVBQUUsRUFBRSxDQUFDO1FBQ25GLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsQyxDQUFDO0NBQ0Y7QUFFRCxlQUFlLFNBQVMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBDb21tYW5kIH0gZnJvbSAncHJvc2VtaXJyb3ItY29tbWFuZHMnO1xuXG5pbXBvcnQgeyBnZXRTZWxlY3Rpb25NYXJrcywgaXNNYXJrQWN0aXZlIH0gZnJvbSAnbmd4LWVkaXRvci9oZWxwZXJzJztcbmltcG9ydCB7IGFwcGx5TWFyaywgcmVtb3ZlTWFyayB9IGZyb20gJ25neC1lZGl0b3IvY29tbWFuZHMnO1xuXG5pbXBvcnQgeyBEaXNwYXRjaCB9IGZyb20gJy4vdHlwZXMnO1xuXG50eXBlIE5hbWUgPSAndGV4dF9jb2xvcicgfCAndGV4dF9iYWNrZ3JvdW5kX2NvbG9yJztcblxuaW50ZXJmYWNlIENvbG9yQXR0cnMge1xuICBjb2xvcjogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQmFja2dyb3VuZENvbG9yQXR0cnMge1xuICBiYWNrZ3JvdW5kQ29sb3I6IHN0cmluZztcbn1cblxuY2xhc3MgVGV4dENvbG9yIHtcbiAgbmFtZTogTmFtZTtcblxuICBjb25zdHJ1Y3RvcihuYW1lOiBOYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuXG4gIGFwcGx5KGF0dHJzOiBDb2xvckF0dHJzIHwgQmFja2dyb3VuZENvbG9yQXR0cnMpOiBDb21tYW5kIHtcbiAgICByZXR1cm4gKHN0YXRlOiBFZGl0b3JTdGF0ZSwgZGlzcGF0Y2g/OiBEaXNwYXRjaCk6IGJvb2xlYW4gPT4ge1xuICAgICAgY29uc3QgeyBzY2hlbWEsIHNlbGVjdGlvbiwgZG9jIH0gPSBzdGF0ZTtcblxuICAgICAgY29uc3QgdHlwZTogTWFya1R5cGUgPSBzY2hlbWEubWFya3NbdGhpcy5uYW1lXTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzZWxlY3Rpb247XG5cbiAgICAgIGlmICghZW1wdHkgJiYgKGZyb20gKyAxID09PSB0bykpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvYy5ub2RlQXQoZnJvbSk7XG4gICAgICAgIGlmIChub2RlPy5pc0F0b20gJiYgIW5vZGUuaXNUZXh0ICYmIG5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgLy8gQW4gYXRvbWljIG5vZGUgKGUuZy4gSW1hZ2UpIGlzIHNlbGVjdGVkLlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXBwbHlNYXJrKHR5cGUsIGF0dHJzKShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgIH07XG4gIH1cblxuICBpc0FjdGl2ZShzdGF0ZTogRWRpdG9yU3RhdGUpOiBib29sZWFuIHtcbiAgICBjb25zdCB7IHNjaGVtYSB9ID0gc3RhdGU7XG4gICAgY29uc3QgdHlwZTogTWFya1R5cGUgPSBzY2hlbWEubWFya3NbdGhpcy5uYW1lXTtcblxuICAgIGlmICghdHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBpc01hcmtBY3RpdmUoc3RhdGUsIHR5cGUpO1xuICB9XG5cbiAgZ2V0QWN0aXZlQ29sb3JzKHN0YXRlOiBFZGl0b3JTdGF0ZSk6IHN0cmluZ1tdIHtcbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0YXRlO1xuICAgIGNvbnN0IG1hcmtzID0gZ2V0U2VsZWN0aW9uTWFya3Moc3RhdGUpO1xuXG4gICAgY29uc3QgY29sb3JzID0gbWFya3NcbiAgICAgIC5maWx0ZXIobWFyayA9PiBtYXJrLnR5cGUgPT09IHNjaGVtYS5tYXJrc1t0aGlzLm5hbWVdKVxuICAgICAgLm1hcChtYXJrID0+IG1hcmsuYXR0cnMuY29sb3IpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgcmV0dXJuIGNvbG9ycztcbiAgfVxuXG4gIHJlbW92ZSgpOiBDb21tYW5kIHtcbiAgICByZXR1cm4gKHN0YXRlOiBFZGl0b3JTdGF0ZSwgZGlzcGF0Y2g/OiBEaXNwYXRjaCk6IGJvb2xlYW4gPT4ge1xuICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0YXRlO1xuXG4gICAgICBjb25zdCB0eXBlID0gc2NoZW1hLm1hcmtzW3RoaXMubmFtZV07XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVtb3ZlTWFyayh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgIH07XG4gIH1cblxuICBjYW5FeGVjdXRlKHN0YXRlOiBFZGl0b3JTdGF0ZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5uYW1lID09PSAndGV4dF9jb2xvcicgPyB7IGNvbG9yOiAnJyB9IDogeyBiYWNrZ3JvdW5kQ29sb3I6ICcnIH07XG4gICAgcmV0dXJuIHRoaXMuYXBwbHkoYXR0cnMpKHN0YXRlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0Q29sb3I7XG4iXX0=