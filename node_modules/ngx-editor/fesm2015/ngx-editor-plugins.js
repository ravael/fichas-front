import { Plugin, PluginKey, NodeSelection } from 'prosemirror-state';
import { DecorationSet, Decoration } from 'prosemirror-view';

const PLACEHOLDER_CLASSNAME = 'NgxEditor__Placeholder';
const placeholderPlugin = (text) => {
    return new Plugin({
        key: new PluginKey('placeholder'),
        state: {
            init() {
                return text !== null && text !== void 0 ? text : '';
            },
            apply(tr, previousVal) {
                var _a;
                const placeholder = (_a = tr.getMeta('UPDATE_PLACEHOLDER')) !== null && _a !== void 0 ? _a : previousVal;
                return placeholder;
            }
        },
        props: {
            decorations(state) {
                var _a;
                const doc = state.doc;
                const placeholder = this.getState(state);
                if (!placeholder) {
                    return DecorationSet.empty;
                }
                if (doc.childCount === 1 && ((_a = doc === null || doc === void 0 ? void 0 : doc.firstChild) === null || _a === void 0 ? void 0 : _a.isTextblock) && doc.firstChild.content.size === 0) {
                    const placeHolderEl = document.createElement('span');
                    placeHolderEl.classList.add(PLACEHOLDER_CLASSNAME);
                    placeHolderEl.textContent = placeholder;
                    return DecorationSet.create(doc, [Decoration.widget(1, placeHolderEl)]);
                }
                return DecorationSet.empty;
            }
        }
    });
};
const ɵ0 = placeholderPlugin;

const editablePlugin = (editable = true) => {
    return new Plugin({
        key: new PluginKey('editable'),
        state: {
            init() {
                return editable;
            },
            apply(tr, previousVal) {
                var _a;
                return (_a = tr.getMeta('UPDATE_EDITABLE')) !== null && _a !== void 0 ? _a : previousVal;
            }
        },
        props: {
            editable(state) {
                return this.getState(state);
            },
            attributes(state) {
                const isEnabled = this.getState(state);
                if (isEnabled) {
                    return null;
                }
                return {
                    class: 'NgxEditor__Content--Disabled'
                };
            }
        }
    });
};
const ɵ0$1 = editablePlugin;

const WRAPPER_CLASSNAME = 'NgxEditor__ImageWrapper';
const WRAPPER_RESIZE_ACTIVE_CLASSNAME = 'NgxEditor__Resizer--Active';
const RESIZE_HANDLE_CLASSNAME = 'NgxEditor__ResizeHandle';
const createHandle = (direction) => {
    const handle = document.createElement('span');
    handle.className = `${RESIZE_HANDLE_CLASSNAME}--${direction}`;
    return handle;
};
const ɵ0$2 = createHandle;
class ImageRezieView {
    constructor(node, view, getPos) {
        var _a, _b;
        const outer = document.createElement('span');
        outer.className = WRAPPER_CLASSNAME;
        outer.style.width = node.attrs.width;
        const handle = document.createElement('span');
        handle.className = RESIZE_HANDLE_CLASSNAME;
        const img = document.createElement('img');
        img.setAttribute('src', node.attrs.src);
        img.setAttribute('alt', (_a = node.attrs.alt) !== null && _a !== void 0 ? _a : '');
        img.setAttribute('title', (_b = node.attrs.title) !== null && _b !== void 0 ? _b : '');
        img.style.width = '100%';
        img.style.height = '100%';
        const handleBottomRight = createHandle('BR');
        const handleTopRight = createHandle('TL');
        const handleTopLeft = createHandle('TR');
        const handleBottomLeft = createHandle('BL');
        const resizePropoptionally = (evt) => {
            evt.preventDefault();
            const { state, dispatch } = view;
            const { tr } = state;
            const startX = evt.pageX;
            const startWidth = img.clientWidth;
            const { width } = window.getComputedStyle(view.dom);
            const editorWidth = parseInt(width, 10);
            const onMouseMove = (e) => {
                const currentX = e.pageX;
                const diffInPx = currentX - startX;
                const computedWidth = startWidth + diffInPx;
                // prevent image overflow the editor
                // prevent resizng below 20px
                if (computedWidth > editorWidth || computedWidth < 20) {
                    return;
                }
                outer.style.width = `${computedWidth}px`;
            };
            const onMouseUp = (e) => {
                e.preventDefault();
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                const transaction = tr.setNodeMarkup(getPos(), undefined, {
                    src: node.attrs.src,
                    width: outer.style.width
                });
                const resolvedPos = transaction.doc.resolve(getPos());
                const newSelection = new NodeSelection(resolvedPos);
                transaction.setSelection(newSelection);
                dispatch(transaction);
            };
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        };
        handleBottomRight.addEventListener('mousedown', resizePropoptionally, { once: true });
        handleTopRight.addEventListener('mousedown', resizePropoptionally, { once: true });
        handleTopLeft.addEventListener('mousedown', resizePropoptionally, { once: true });
        handleBottomLeft.addEventListener('mousedown', resizePropoptionally, { once: true });
        handle.appendChild(handleBottomRight);
        handle.appendChild(handleTopRight);
        handle.appendChild(handleTopLeft);
        handle.appendChild(handleBottomLeft);
        outer.appendChild(handle);
        outer.appendChild(img);
        this.dom = outer;
        this.img = img;
        this.handle = handle;
    }
    selectNode() {
        this.dom.classList.add(WRAPPER_RESIZE_ACTIVE_CLASSNAME);
        this.handle.style.display = 'block';
    }
    deselectNode() {
        this.dom.classList.remove(WRAPPER_RESIZE_ACTIVE_CLASSNAME);
        this.handle.style.display = 'none';
    }
}
const defaultOptions = {
    resize: true,
};
const imagePlugin = (opts = defaultOptions) => {
    const options = Object.assign(Object.assign({}, defaultOptions), opts);
    return new Plugin({
        key: new PluginKey('link'),
        props: {
            nodeViews: {
                image: (node, view, getPos) => {
                    if (!options.resize) {
                        return null;
                    }
                    return new ImageRezieView(node, view, getPos);
                },
            }
        }
    });
};
const ɵ1 = imagePlugin;

/**
 * Generated bundle index. Do not edit.
 */

export { editablePlugin as editable, imagePlugin as image, placeholderPlugin as placeholder };
//# sourceMappingURL=ngx-editor-plugins.js.map
